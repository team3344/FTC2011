#pragma config(Sensor, S4,     HTSMUX,                sensorI2CCustomStd)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * $Id: SMUX-test1.c 25 2010-05-11 13:18:02Z xander $
 */

/**
 * SMUX-test1.c is a demo program to show off the SMUX's capabilties and the ROBOTC
 * API that exposes them.
 *
 * License: You may use this code as you wish, provided you give credit where it's due.
 *
 * THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 2.00 AND HIGHER.
 * Xander Soldaat (mightor_at_gmail.com)
 * 15 September 2009
 * version 0.2
 */

// Include all of the drivers for the supported devices.
#include "drivers/common.h"
#include "drivers/HTIRS2-driver.h"
#include "drivers/LEGOUS-driver.h"
#include "drivers/HTMC-driver.h"
#include "drivers/HTCS-driver.h"
#include "drivers/HTCS2-driver.h"
#include "drivers/HTAC-driver.h"
#include "drivers/HTIRS-driver.h"
#include "drivers/HTPB-driver.h"  // to be done

// What are we currently doing or about to.  This is used by state engine.
typedef enum {
  STATE_SCANNING = 0,
  STATE_MAINMENU,
  STATE_SHOWSENSOR
} tMenuState;

// Keep track of current state and previous one
tMenuState menuState;
tMenuState prevState;

// Current sensor number and array of strings to hold human names of the sensors.
int activeSensor = 0;
string sensorTypes[4];

// Function prototypes
void debounce();
void doScan(tSensors link);
void doMainMenu();
void doDisplaySensor();
void doColourSensor(tMUXSensor muxsensor);
void doColourSensor2(tMUXSensor muxsensor);
void doCompassSensor(tMUXSensor muxsensor);
void doLegoSonar(tMUXSensor muxsensor);
void doAnalogue(tMUXSensor muxsensor);
void doIRSeeker(tMUXSensor muxsensor);
void doIRSeekerNew(tMUXSensor muxsensor);
void doAccel(tMUXSensor muxsensor);

/**
 * Wait until no button is pressed. Also known as debouncing.
 */
void debounce() {
  while(nNxtButtonPressed != kNoButton) {
     wait1Msec(10);
  }
}

/**
 * Perform a scan of the SMUX, this populates the sensorTypes string array.<br>
 * If an error occurs, it will attempt to issue the scan command up to 20 times.
 * @param link the SMUX port number
 */
void doScan(tSensors link) {
  int error_count = 1;
  eraseDisplay();
  nxtDisplayCenteredBigTextLine(2, "Scanning");
  HTSMUXinit();
  while (!HTSMUXscanPorts(link)) {
    if (error_count > 20)
      StopAllTasks();
    PlaySound(soundBeepBeep);
    nxtDisplayCenteredBigTextLine(0, "ERROR");
    while(bSoundActive) { wait1Msec(1);}
    nxtDisplayCenteredTextLine(4, "Try %d/20", error_count);
    nxtDisplayCenteredTextLine(6, "Reconnect SMUX");
    nxtDisplayCenteredTextLine(7, "to S4");
    wait1Msec(2000);
    error_count++;
    HTSMUXinit();
  }
  for (int i = 0; i < 4; i++) {
    HTSMUXsensorTypeToString(smuxData[link].sensor[i], sensorTypes[i]);
  }
  prevState = STATE_SCANNING;
  menuState = STATE_MAINMENU;
}


/**
 * Draw the main menu from which sensors can be selected.
 */
void doMainMenu() {
  eraseDisplay();
  nxtDisplayTextLine(0, "Pick a sensor");
  nxtDisplayTextLine(6, "[enter] to select");
  nxtDisplayTextLine(7, "[exit] to rescan");
  for (int i = 0; i < 4; i++) {
    if (i == activeSensor) {
      // The arrow indicates the currently selected sensor
      nxtDisplayTextLine(i+1, "-> %s", sensorTypes[i]);
    } else {
      nxtDisplayTextLine(i+1, "   %s", sensorTypes[i]);
    }
  }

  while (true) {
    switch(nNxtButtonPressed) {
      case kExitButton:
          prevState = STATE_MAINMENU;
          menuState = STATE_SCANNING;
          debounce();
          return;
      case kRightButton:
          if (activeSensor < 3)
            activeSensor++;
          else
            activeSensor = 0;
          debounce();
          return;
      case kLeftButton:
          if (activeSensor > 0)
            activeSensor--;
          else
            activeSensor = 3;
          debounce();
          return;
       case kEnterButton:
          prevState = STATE_MAINMENU;
          menuState = STATE_SHOWSENSOR;
          debounce();
          doDisplaySensor();
          return;
    }
  }
}


/**
 * Select the appropriate muxsensor and fire up the function that
 * displays the sensor data.
 */
void doDisplaySensor() {
  tMUXSensor muxsensor;

  eraseDisplay();
  switch(activeSensor) {
    case 0: muxsensor = msensor_S4_1; break;
    case 1: muxsensor = msensor_S4_2; break;
    case 2: muxsensor = msensor_S4_3; break;
    case 3: muxsensor = msensor_S4_4; break;
  }

  switch(HTSMUXreadSensorType(HTSMUX, activeSensor)) {
    case HTSMUXAnalogue: doAnalogue(muxsensor); break;
    case HTSMUXLegoUS: doLegoSonar(muxsensor); break;
    case HTSMUXCompass: doCompassSensor(muxsensor); break;
    case HTSMUXColor: doColourSensor(muxsensor); break;
    case HTSMUXColorNew: doColourSensor2(muxsensor); break;
    case HTSMUXAccel: doAccel(muxsensor); break;
    case HTSMUXIRSeeker: doIRSeeker(muxsensor); break;
    case HTSMUXProto: nxtDisplayCenteredBigTextLine(2, "Proto");wait1Msec(2000); break;
    case HTSMUXIRSeekerNew: doIRSeekerNew(muxsensor); break;
  }
  debounce();
  prevState = STATE_SHOWSENSOR;
  menuState = STATE_MAINMENU;
  return;
}


/**
 * Display the colour sensor data.  This is done with 3 bars, one for each
 * primary colour.  The current color number is also displayed.
 * @param muxsensor the SMUX sensor port number
 */
void doColourSensor(tMUXSensor muxsensor) {
  int red, green, blue = 0;
  int _colour = 0;
  string _tmp;

  while (nNxtButtonPressed != kExitButton) {
    _colour = HTCSreadColor(muxsensor);
    if (_colour < 0) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    if (!HTCSreadRGB(muxsensor, red, green, blue)) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    nxtDisplayCenteredTextLine(0, "Color: %d", _colour);
    nxtDisplayCenteredBigTextLine(1, "R  G  B");

    nxtEraseRect(0,10, 99, 41);
    nxtFillRect( 0, 10, 30, 10 + (red+1)/8);
    nxtFillRect(35, 10, 65, 10 + (green+1)/8);
    nxtFillRect(70, 10, 99, 10 + (blue+1)/8);
    StringFormat(_tmp, " %3d   %3d", red, green);
    nxtDisplayTextLine(7, "%s   %3d", _tmp, blue);

    wait1Msec(50);
  }
  debounce();
}


/**
 * Display the colour sensor data.  This is done with 3 bars, one for each
 * primary colour.  The current color number is also displayed.
 * @param muxsensor the SMUX sensor port number
 */
void doColourSensor2(tMUXSensor muxsensor) {
  int red, green, blue = 0;
  int _colour = 0;
  string _tmp;

  while (nNxtButtonPressed != kExitButton) {
    //eraseDisplay();
    _colour = HTCS2readColor(muxsensor);

    // If colour == -1, it implies an error has occurred
    if (_colour < 0) {
      nxtDisplayTextLine(4, "ERROR!!");
      wait1Msec(2000);
      StopAllTasks();
    }

    // A return value of false imples an error has occurred
    if (!HTCS2readRGB(muxsensor, red, green, blue)) {
      nxtDisplayTextLine(4, "ERROR!!");
      wait1Msec(2000);
      StopAllTasks();
    }

    nxtDisplayCenteredTextLine(0, "Color: %d", _colour);
    nxtDisplayCenteredBigTextLine(1, "R  G  B");

    nxtEraseRect(0,10, 99, 41);
    nxtFillRect( 0, 10, 30, 10 + (red+1)/8);
    nxtFillRect(35, 10, 65, 10 + (green+1)/8);
    nxtFillRect(70, 10, 99, 10 + (blue+1)/8);
    StringFormat(_tmp, " %3d   %3d", red, green);
    nxtDisplayTextLine(7, "%s   %3d", _tmp, blue);

    wait1Msec(100);
  }
  debounce();
}


/**
 * Display the compass sensor data.  Draws a circle with the current
 * heading displayed as a line with a little circle in the middle and
 * one on the end.
 * @param muxsensor the SMUX sensor port number
 */
void doCompassSensor(tMUXSensor muxsensor) {
  float x;
  float y;
  float oldx;
  float oldy;
  int heading = 0;
  while (nNxtButtonPressed != kExitButton) {
    heading = HTMCreadHeading(muxsensor);
    if (heading < 0) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    nxtDisplayTextLine(0, "Abs");
    nxtDisplayTextLine(1, "%3d", heading);
    y = 30*cosDegrees(heading);
    x = 30*sinDegrees(heading);
    nxtEraseEllipse(60 + (int)oldx-2, 32+(int)oldy-2, 60 + (int)oldx+2, 32+(int)oldy+2);
    nxtEraseLine(60, 32, 60 + (int)oldx, 32+(int)oldy);
    nxtDrawEllipse(30, 62, 90, 2);
    nxtDrawLine(60, 32, 60 + (int)x, 32+(int)y);
    nxtFillEllipse(60 - 1, 32 - 1, 60 + 1, 32 + 1);
    nxtFillEllipse(60 + (int)x-2, 32+(int)y-2, 60 + (int)x+2, 32+(int)y+2);
    oldx = x;
    oldy = y;
    wait1Msec(50);
  }
  debounce();
}


/**
 * Display the Lego Ultra Sonic sensor data.  This draws a small stick figure
 * that moves closer to or further away from a wall depending on the sensor reading.
 * @param muxsensor the SMUX sensor port number
 */
void doLegoSonar(tMUXSensor muxsensor) {
  int dist = 0;
  int olddist = 0;
  int startx = 10;
  int ypos = 30;
  int xpos = 0;
  int xposold = 0;

  while (nNxtButtonPressed != kExitButton) {
    dist = USreadDist(muxsensor);
    if (dist == 255) dist = olddist;
    if (olddist != dist) {
      xpos = startx + ((255 - dist) / 4);
      xposold = startx + ((255 - olddist) / 4);
      nxtEraseRect(xposold - 7, ypos + 12, xposold+7, ypos-7);
      nxtDrawEllipse(xpos-2, ypos+10, xpos+2, ypos+5);
      nxtDrawLine(xpos, ypos+5, xpos, ypos+3);
      nxtDrawLine(xpos-5, ypos+3, xpos+5, ypos+3);
      nxtFillEllipse(xpos-2, ypos+3, xpos+2, ypos-2);
      nxtDrawLine(xpos, ypos+3, xpos-4, ypos-6);
      nxtDrawLine(xpos, ypos+3, xpos+4, ypos-6);
      nxtFillRect(80, ypos + 15, 82, ypos - 6);
      olddist = dist;
      nxtDisplayTextLine(7, "Distance: %3d cm", dist);
    }
    wait1Msec(50);
  }
  debounce();
}



/**
 * Display the analogue sensor data.  Toggle the LED by pressing [enter].
 * @param muxsensor the SMUX sensor port number
 */
void doAnalogue(tMUXSensor muxsensor) {
  int raw = 0;
  int oldraw = 0;
  bool active = true;

  eraseDisplay();

  nxtDisplayCenteredBigTextLine(1, "Analogue");
  nxtDisplayTextLine(7, "[enter] set led");
  raw = HTSMUXreadAnalogue((tSensors)SPORT(muxsensor), MPORT(muxsensor));
  nxtDisplayCenteredBigTextLine(4, "%d", raw);
  while (true) {
    switch(nNxtButtonPressed) {
      case kEnterButton:
                        active = !active;
                        if (!active) {
                            HTSMUXsetMode((tSensors)SPORT(muxsensor), MPORT(muxsensor), HTSMUX_CHAN_DIG0_HIGH);
                            HTSMUXsendCommand((tSensors)SPORT(muxsensor), HTSMUX_CMD_RUN);
                        }
                        else
                        if (active) {
													  HTSMUXsetMode((tSensors)SPORT(muxsensor), MPORT(muxsensor), 0);
													  HTSMUXsendCommand((tSensors)SPORT(muxsensor), HTSMUX_CMD_RUN);
                        }

                        debounce();
                        break;

      case kExitButton:
                        return;
    }

    raw = HTSMUXreadAnalogue((tSensors)SPORT(muxsensor), MPORT(muxsensor));

    if (raw != oldraw) {
      nxtDisplayCenteredBigTextLine(4, "%d", raw);
      oldraw = raw;
    }

    wait1Msec(10);
  }
}


/**
 * Display the IR Seeker (v1) sensor data. Not very fancy but effective.
 * @param muxsensor the SMUX sensor port number
 */
void doIRSeeker(tMUXSensor muxsensor) {
  int _dir = 0;
  int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
  while(nNxtButtonPressed != kExitButton) {
    // read all of the sensors' values at once
    if (!HTIRSreadAllStrength(muxsensor, dcS1, dcS2, dcS3, dcS4, dcS5)) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    // read the direction from which the signal is coming
    _dir = HTIRSreadDir(muxsensor);
    if (_dir < 0) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    // display the info from the sensor
    nxtDisplayTextLine(0,"HT IR Seeker");
    nxtDisplayTextLine(2, "dir:  %d", _dir);
    nxtDisplayTextLine(4, "Sensor strength:");
    nxtDisplayTextLine(5, "S1: %3d  S2: %3d", ubyteToInt(dcS1), ubyteToInt(dcS2));
    nxtDisplayTextLine(6, "S3: %3d  S4: %3d", ubyteToInt(dcS2), ubyteToInt(dcS4));
    nxtDisplayTextLine(7, "S5: %3d", ubyteToInt(dcS4));
    wait10Msec(50);
  }
}


/**
 * Display the IR Seeker (v2) sensor data. Not very fancy but effective.<br>
 * Both DC and AC values are displayed for the current light source(s).
 * @param muxsensor the SMUX sensor port number
 */
void doIRSeekerNew(tMUXSensor muxsensor) {
  int _dirDC = 0;
  int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

  while(nNxtButtonPressed != kExitButton)
  {
    _dirDC = HTIRS2readDCDir(muxsensor);
    if (_dirDC < 0) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    _dirAC = HTIRS2readACDir(muxsensor);
    if (_dirAC < 0) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    if (!HTIRS2readAllDCStrength(muxsensor, dcS1, dcS2, dcS3, dcS4, dcS5)) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    if (!HTIRS2readAllACStrength(muxsensor, acS1, acS2, acS3, acS4, acS5 )) {
      prevState = STATE_MAINMENU;
      menuState = STATE_SCANNING;
      return;
    }

    nxtDisplayTextLine(0,"HT IR Seeker V2");
    nxtDisplayTextLine(1, "       DC   AC");
    nxtDisplayTextLine(2, "DIR:  %3d  %3d", _dirDC, _dirAC);
    nxtDisplayTextLine(3, "S1:   %3d  %3d", dcS1, acS1);
    nxtDisplayTextLine(4, "S2:   %3d  %3d", dcS2, acS2);
    nxtDisplayTextLine(5, "S3:   %3d  %3d", dcS3, acS3);
    nxtDisplayTextLine(6, "S4:   %3d  %3d", dcS4, acS4);
    nxtDisplayTextLine(7, "S5:   %3d  %3d", dcS5, acS5);
    wait1Msec(50);
  }
}


/**
 * Display the Acceleration Sensor data.
 * @param muxsensor the SMUX sensor port number
 */
void doAccel(tMUXSensor muxsensor) {
	int _x_axis2 = 0;
	int _y_axis2 = 0;
	int _z_axis2 = 0;

	string _tmp;

  eraseDisplay();
  nxtDisplayCenteredBigTextLine(1, "Accel");
  while (nNxtButtonPressed != kExitButton) {
    if (!HTACreadAllAxes(muxsensor, _x_axis2, _y_axis2, _z_axis2)) {
      return;
    }

    // We can't provide more than 2 parameters to nxtDisplayTextLine(),
    // so we'll do in two steps using StringFormat()
    nxtDisplayTextLine(3, "     X    Y    Z");
    StringFormat(_tmp, "  %4d %4d", _x_axis2, _y_axis2);
    nxtDisplayTextLine(4, "%s %4d", _tmp, _z_axis2);

    wait1Msec(100);
  }
}


task main () {
  nNxtButtonTask = -2;
  nNxtExitClicks = 3;

  nxtDisplayCenteredTextLine(0, "HiTechnic");
  nxtDisplayCenteredBigTextLine(1, "SMUX");
  nxtDisplayCenteredTextLine(3, "Demo prog");
  nxtDisplayCenteredTextLine(5, "Connect SMUX to");
  nxtDisplayCenteredTextLine(6, "S4 and sensors");
  nxtDisplayCenteredTextLine(7, "to SMUX");
  wait1Msec(2000);

  eraseDisplay();
  prevState = STATE_MAINMENU;
  menuState = STATE_SCANNING;

  while (true) {
    switch (menuState) {
      case STATE_SCANNING:
          doScan(HTSMUX);
          break;
      case STATE_MAINMENU:
          doMainMenu();
          break;
    }
  }
}

/*
 * $Id: SMUX-test1.c 25 2010-05-11 13:18:02Z xander $
 */
