#pragma config(Sensor, S1,     Light,               sensorLightActive)
#pragma config(Sensor, S2,     SonarRight,          sensorSONAR)
#pragma config(Motor,  motorA,          Conveyer,      tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct {
	float Kp, Ki, Kd;	//	gain constants
	float integral;
	float previousTime;
	float previousError;
	float previousSignal;
	float targetSignal;
} PIDController;



void CreateDriveMotorPIDController(PIDController& pidOut);


float PIDControllerCalculate(PIDController& controller, float signal)
{
	float dT = nPgmTime - controller.previousTime;

	float error = signal - controller.targetSignal;
	controller.integral += (error * dT);
	float nextErrorPrediction = (error - controller.previousError) + error;	//	previous change in error added to current error


	float P = controller.Kp * error;
	float I = controller.Ki * controller.integral;
	float D = controller.Kd * nextErrorPrediction / dT;


	//	store info for next iteration
	controller.previousError = error;
	controller.previousSignal = signal;
	controller.previousTime = nPgmTime;	//	set it to the current time


  return -(P + I + D);
}



float ScanForLineEdgeValue()
{
  int max, min = 100;
 motor[motorA] = 20;
 motor[motorB] = -20;
 while ( nMotorEncoder[motorA] < 360 )
 {
   int light = SensorValue[Light];
   if ( light > max) max = light;
   if ( light < min) min = light;

   nxtDisplayTextLine(0, (string)min);
   nxtDisplayTextLine(1, (string)max);
   nxtDisplayTextLine(2, (string)light);
 }

 motor[motorB] = 20;
 motor[motorA] = -20;
 while ( nMotorEncoder[motorA] > -360)
 {
   int light = SensorValue[Light];
   if ( light > max) max = light;
   if ( light < min) min = light;

   nxtDisplayTextLine(0, (string)min);
   nxtDisplayTextLine(1, (string)max);
   nxtDisplayTextLine(2, (string)light);
 }


 motor[motorA] = 0;
 motor[motorB] = 0;


 return (max + min) / 2;
}




task main()
{
  wait10Msec(50);

  float edgeValue = 46;//ScanForLineEdgeValue();


  nxtDisplayTextLine(0, (string)edgeValue;
  wait10Msec(200);



  PIDController pid;
  pid.targetSignal = edgeValue;


  pid.Kp = 2; //  1 was a good value







  //motor[motorA] = 10; //  start value

  //float previousTime;
  //float previousEncoder;
  float power = 25;

  while ( true )
  {
    float signal = SensorValue[Light];//(float)(nMotorEncoder[motorA] - previousEncoder) / (float)(nPgmTime - previousTime);


    nxtDisplayTextLine(0, (string)signal);

    float turn = PIDControllerCalculate(pid, signal);
    motor[motorA] = power + turn;
    motor[motorB] = power - turn;

    //previousEncoder = nMotorEncoder[motorA];
    //previousTime = nPgmTime;
    wait1Msec(5);
  }



}
