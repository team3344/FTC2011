#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Motor,  motorA,          j,             tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          ba,            tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Front,         tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Back,          tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Left,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Right,         tmotorNormal, openLoop)
#pragma config(Sensor, S2,     Accelerometer,       sensorI2CHiTechnicAccel)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "../HT RobotC Drivers/drivers/HTAC-driver.h"

#define InRange(val, min, matilt) (val <= matilt && val >= min)



#define kMaxTilt -12
#define kMinTilt -28
#define kBalancedTilt -20



#define balance_speed 7


void stop()
{
 motor[Left] = 0;
 motor[Right] = 0;
}



task main()
{


  nMotorPIDSpeedCtrl[Left] = mtrSpeedReg; //  pid speed control
  nMotorPIDSpeedCtrl[Right] = mtrSpeedReg;




  short tilt;
  wait10Msec(200);
  HTACreadX(Accelerometer, tilt);



 while ( !InRange(tilt, kMinTilt, kMaxTilt) )  //  while we're not balanced
 {
    nxtDisplayCenteredTextLine(0, (string)tilt);


   // float error = (float)kBalancedTilt - (float)tilt;

    //float speed = -(error / 20.0) * balance_speed;


    //motor[Left] = speed;
    //motor[Right] = speed;



    if ( tilt > kMaxTilt )  //  we're too far back
    {
      motor[Left] = balance_speed;
      motor[Right] = balance_speed;
    }
    else  //  we're too far forward
    {
      motor[Left]= -balance_speed;
      motor[Right] = -balance_speed;
    }


    wait10Msec(30);
    stop();
    wait10Msec(50);


    HTACreadX(Accelerometer, tilt);
 }


 stop();


 PlaySound(soundUpwardTones);
 wait1Msec(2000);

}
