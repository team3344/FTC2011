#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     HTSMUX,              sensorNone)
#pragma config(Sensor, S3,     Accelerometer,       sensorI2CHiTechnicAccel)
#pragma config(Sensor, S4,     Sonar,               sensorSONAR)
#pragma config(Motor,  motorA,          Conveyor,      tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          IndicatorLight, tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Front,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Back,          tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Left,          tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Right,         tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Kicker,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    Slide,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    Door,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////


#include "shared/include.c"
#include "Autonomous/include.c"
#include "HT RobotC Drivers/drivers/HTAC-driver.h"
#include "HT RobotC Drivers/drivers/HTIRS2-driver.h"
#include "HT RobotC Drivers/drivers/HTMag-driver.h"


void initializeRobot()
{
	FieldInit();	//  initialize the map of the field
	//FTCTeamSetCurrent(FTCTeamRed);					//	tell it what team we are on
	//FTCFieldSetStartPosition(FTCStartPositionLeft);	//	tell it which start square we're on

  //  FIXME: get start position!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! location, node!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	HTSMUXinit();             //  init the sensor multiplexor
	HTSMUXscanPorts(HTSMUX);  //  tell smux to detect connected sensors


	MechanismInit();


	PlaySound(soundUpwardTones);
}



static bool gettingDoubler;	//	global variable that tells whether or not the GetDoublerBaton task is running

task GetDoublerBaton()
{
	gettingDoubler = true;


	Node d;// = FTCFieldGetKeyPointOfCenterDispenserForTeam(FTCTeamGetCurrent());	//	get key point of the dispenser
	Node c = MapGetCurrentNode();
	RobotTravelFromNodeToNode(d, c);	// go to the dispenser

	//	FIXME: turn towards it

	RobotMountCenterDispenser();	//	get aligned with the dispenser



	StartTask(MechanismCycleConveyor);		//	pull in the doubler baton & a few others
	while ( MechanismConveyorIsRunning() ) { wait10Msec(100); } //  wait until it's done
	//	FIXME: backup to node


	gettingDoubler = false;
}



void GetToBridgeAndBalance()
{
	Node bridgeID = FTCFieldGetNodeOfBridgeForTeam(FTCTeamGetCurrent());	//	FIXME: get id of closest bridge!!!!!!!!!!!!
	Node currentID = MapGetCurrentNode();
	RobotTravelFromNodeToNode(currentID, bridgeID);	//	go to the bridge

	RobotBalance();	//	use the accelerometor to balance the bot
}




task main()
{
	initializeRobot();

	waitForStart();		// Wait for the beginning of autonomous phase.

	long startTime = nPgmTime;





	StartTask(GetDoublerBaton);

	while ( true )
	{
		wait10Msec(100);	//	wait 1 second

		if ( nPgmTime - startTime < 25000 )	//	if 25 seconds are up, abort the doubler mission and go balance on bridge
		{
			//	FIXME: abort baton getting

			break;
		}
		else if ( !gettingDoubler )	//	see if we're done getting the doubler yet
		{
			break;
		}
	}

  GetToBridgeAndBalance();
}
