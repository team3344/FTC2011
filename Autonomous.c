#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ElevatorBottomStop,     sensorTouch)
#pragma config(Sensor, S3,     SMUX2,               sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX1,               sensorI2CCustom)
#pragma config(Motor,  motorA,          IndicatorLight, tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  motorC,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Right,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Elevator,      tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Kicker,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    Gate,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    Slide,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    RightStomper,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    LeftStomper,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//  SMUX1
#define Magnet msensor_S4_4
#define Sonar msensor_S4_3
#define Accelerometer msensor_S4_2


//  SMUX2
#define ElevatorTopStop msensor_S3_1
#define IR msensor_S3_2
#define LeftLightSensor msensor_S3_3
#define RightLightSensor msensor_S3_4



//#include "JoystickDriver.c"
#include "shared/include.c"
#include "Autonomous/include.c"


void ff2() {}
void ff3() {}



bool vibrating = false;
task vibrate()
{
  vibrating = true;

  int encoder = 20;

  motor[Left] = 20;
  while ( nMotorEncoder[Left] < encoder ) {}

  motor[Left] = -25;
  while ( nMotorEncoder[Left] > 0 ) {}


  motor[Left] = 0;

  vibrating = false;
}





void initializeRobot()
{
	FieldInit();	//  initialize the map of the field
	SensorsInit();
  MechanismInit();

	FTCGetStartPosition();	//	ask the user where the robot is starting

	PlaySound(soundUpwardTones);
}


void Dispense5Batons()
{
  //  put the elevator up to the top
  motor[Elevator] = kElevatorSpeed;
  while ( !ElevatorIsAtTop() ) {}
  motor[Elevator] = 0;

  //  position slide
  servo[Slide] = kSlideLongPosition;

  //  kick batons out
  servo[Kicker] = kKickerSpeed;
  int endTime = nPgmTime + 10000;  //go for 9 seconds

  nMotorEncoder[Left] = 0;  //  reset encoder so vibrate works ok
  while ( nPgmTime < endTime )
  {
    if ( !vibrating ) StartTask(vibrate); //  vibrate to make sure the batons come out
  }

  servo[Slide] = kSlideMaxPosition;
  wait10Msec(20);

  servo[Kicker] = kKickerStopped;
}



task main()
{
	initializeRobot();

	//waitForStart();	//  FIXME: add this back in!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	long startTime = nPgmTime;


  servo[Slide] = kSlideLongPosition;  //  extend the slide out


	/**********   Preloads   **********/

  //
  //
	//	FIXME: score preloads
  //
  //





	if ( FieldGetCurrentNode() == NodeFriendStartSquareLeft ) //  left start position;
	{
	  RobotTravelFromNodeToNode(FieldGetCurrentNode(), NodeLine1BottomEnd, false);





	  //  FIXME: line up






	  Dispense5Batons();




	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine1BottomEnd, location);
	  RobotMoveToLocation(location, true, false);
	}
	else
	{
	  RobotRotateToOrientation(3.0159423);
	  RobotMoveDistance(21, false);

	  RobotRotateToOrientation(PI / 3.5);
	  //RobotMoveDistance(2, false);


	  //  FIXME: line up





	  Dispense5Batons();



	  wait10Msec(1000); //  FIXME: remoave this wait



	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine3BottomEnd, location);
	  RobotMoveToLocation(location, true, false);
	}

	servo[Slide] = kSlideDownPosition;  //  retract the slide to keep it protected



	/********** End Preloads  **********/



	PlaySound(soundUpwardTones);
	wait10Msec(10000);





	/**********  Mission   **********/

	//  where we are and where we're going
	Node dest = NodeFriendDispenserCenter;
	Node src = FieldGetCurrentNode();

	if ( RobotTravelFromNodeToNode(src, dest, true) )	// go to the dispenser.  avoid enemies
  {
    RobotRotateToOrientation(PI); //  turn towards dispenser
    MechanismElevatorSetHeight(kElevatorHeightMidDispenser);  //  get the elevator to the right height

    if ( RobotMountCenterDispenser() )	//	get aligned with the dispenser
    {
	    //  FIXME: get 5 batons
	    //  FIXME: make a mess with the rest
    }





  }

	//	FIXME: backup to node
  //  FIXME: set elevator to reasonable height




  /**********   End Mission   **********/




  /**********   Balance   **********/

  if ( (nPgmTime - startTime ) > 10000 )  //  balance on the bridge if there's more than 10 seconds left
	{
	  Node bridgeID = NodeFriendBridgeCenter;	//	FIXME:  id of closest bridge???
	  Node currentID = FieldGetCurrentNode();
	  RobotTravelFromNodeToNode(currentID, bridgeID, true);	//	go to the bridge

	  RobotBalance();	//	use the accelerometor to balance the bot
	}

	/**********   End Balance **********/
}
