#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ElevatorBottomStop,     sensorTouch)
#pragma config(Sensor, S3,     SMUX2,               sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX1,               sensorI2CCustom)
#pragma config(Motor,  motorA,          IndicatorLight, tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  motorC,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Right,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Elevator,      tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Kicker,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    Gate,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    Slide,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    RightStomper,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    LeftStomper,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//  SMUX1
#define Magnet msensor_S4_4
#define Sonar msensor_S4_3
#define Accelerometer msensor_S4_2


//  SMUX2
#define ElevatorTopStop msensor_S3_1
#define IR msensor_S3_2
#define LeftLightSensor msensor_S3_3
#define RightLightSensor msensor_S3_4



//#include "JoystickDriver.c"
#include "shared/include.c"
#include "Autonomous/include.c"



bool vibrating = false;
task vibrate()
{
  vibrating = true;

  int encoder = 10;
  int speed = 18;

  motor[Left] = speed;
  while ( nMotorEncoder[Left] < encoder ) {}

  motor[Left] = -speed;
  while ( nMotorEncoder[Left] > 0 ) {}


  motor[Left] = 0;

  vibrating = false;
}





void initializeRobot()
{
	FieldInit();	//  initialize the map of the field
	SensorsInit();
  MechanismInit();

	FTCGetStartPosition();	//	ask the user where the robot is starting

	PlaySound(soundUpwardTones);
}


void Dispense5Batons()
{
  //  put the elevator up to the top
  motor[Elevator] = kElevatorSpeed;
  while ( !ElevatorIsAtTop() ) {}
  motor[Elevator] = 0;

  //  position slide
  servo[Slide] = kSlideLongPosition;

  //  kick batons out
  servo[Kicker] = kKickerSpeed;
  int endTime = nPgmTime + 8000;  //go for 8 seconds

  nMotorEncoder[Left] = 0;  //  reset encoder so vibrate works ok
  while ( nPgmTime < endTime )
  {
    if ( !vibrating ) StartTask(vibrate); //  vibrate to make sure the batons come out
  }

  servo[Slide] = kSlideMaxPosition;
  wait10Msec(20);

  servo[Kicker] = kKickerStopped;
}


#define PRELOADS 1
#define MISSION 0
#define BALANCE 0



task main()
{
	initializeRobot();

	//waitForStart();	//  FIXME: add this back in!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	long startTime = nPgmTime;


  servo[Slide] = kSlideLongPosition;  //  extend the slide out


	/**********   Preloads   **********/
#if PRELOADS == 1

	if ( FieldGetCurrentNode() == NodeFriendStartSquareLeft ) //  left start position;
	{
	  RobotRotateToOrientation(0.13);
	  RobotMoveDistance(20, false);
	  RobotRotateToOrientation(-1.5 + (PI / 8.5));





	  //  FIXME: line up






	  Dispense5Batons();




	  wait10Msec(1000); //  FIXME: remove this wait


	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine1BottomEnd, location);
	  RobotMoveToLocation(location, false, false);
	  FieldSetCurrentNode(NodeLine1BottomEnd);
	}
	else
	{
	  RobotRotateToOrientation(3.0159423);
	  RobotMoveDistance(21, false);

	  RobotRotateToOrientation(PI / 3.5);


	  //  FIXME: line up





	  Dispense5Batons();



	  wait10Msec(1000); //  FIXME: remove this wait



	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine3BottomEnd, location);
	  RobotMoveToLocation(location, false, false);
	  FieldSetCurrentNode(NodeLine3BottomEnd);
	}

	servo[Slide] = kSlideDownPosition;  //  retract the slide to keep it protected




#endif
	/********** End Preloads  **********/






	/**********  Mission   **********/
#if MISSION == 1

	//  where we are and where we're going
	Node src = FieldGetCurrentNode();
	Node dest = NodeFriendDispenserCenter;

	if ( RobotTravelFromNodeToNode(src, dest, true) )	// go to the dispenser.  avoid enemies
  {
    RobotRotateToOrientation(PI / 2.0); //  turn towards dispenser

    servo[Gate] = kGateUpPosition;

    MechanismElevatorSetHeight(kElevatorHeightMidDispenser);  //  get the elevator to the right height

    if ( RobotMountCenterDispenser() )	//	get aligned with the dispenser
    {
      MechanismElevatorSetHeight(kElevatorHeightMidDispenser + 1);  //  FIXME: is this good

      //  FIXME: DO WORK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


      //  FIXME: put the elevator back down????
    }


    servo[Gate] = kGateDownPosition;


  }

  Vector location;
  FieldGetNodeLocation(NodeFriendDispenserCenter, location);
  RobotMoveToLocation(location, true, false);   //  backup to the node


#endif
  /**********   End Mission   **********/




  /**********   Balance   **********/
#if BALANCE == 1

  if ( (nPgmTime - startTime ) > 10000 )  //  balance on the bridge if there's more than 10 seconds left
	{
	  Node bridgeID = NodeFriendBridgeCenter;	//	FIXME:  id of closest bridge???
	  Node currentID = FieldGetCurrentNode();
	  RobotTravelFromNodeToNode(currentID, bridgeID, true);	//	go to the bridge

	  RobotBalance();	//	use the accelerometor to balance the bot
	}

#endif
	/**********   End Balance **********/
}
