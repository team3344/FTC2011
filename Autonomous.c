#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ElevatorBottomStop,     sensorTouch)
#pragma config(Sensor, S3,     SMUX2,               sensorI2CCustom)
#pragma config(Sensor, S4,     SMUX1,               sensorI2CCustom)
#pragma config(Motor,  motorA,          IndicatorLight, tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  motorC,          ,              tmotorNormal, PIDControl)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Right,         tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Elevator,      tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Intake,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_2,    LeftStomper,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    Flap,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    KickerStomper,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    Slide,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    RightStomper,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//  SMUX1
#define Magnet msensor_S4_2 //  FIXME: this isn't right port? //  FIXME: it isn't connected
#define LeftLightSensor msensor_S4_2
#define RightLightSensor msensor_S4_1
#define IR msensor_S4_4


//  SMUX2
#define ElevatorTopStop msensor_S3_1
#define Accelerometer msensor_S3_4


#include "JoystickDriver.c"
#include "shared/include.c"
#include "Autonomous/include.c"



bool vibrating = false;
task vibrate()
{
  vibrating = true;

  int encoder = 10;
  int speed = 15;

  motor[Left] = speed;
  while ( nMotorEncoder[Left] < encoder ) {}

  motor[Left] = -speed;
  while ( nMotorEncoder[Left] > 0 ) {}


  motor[Left] = 0;

  vibrating = false;
}





void initializeRobot()
{
	FieldInit();	//  initialize the map of the field
	SensorsInit();
  MechanismInit();


	FTCGetStartInfo();	//	ask the user where the robot is starting

	PlaySound(soundUpwardTones);
}


void Dispense5Batons()
{
  PlaySound(soundFastUpwardTones);

  //  put the elevator up to the top
  motor[Elevator] = kElevatorSpeed;
  while ( !ElevatorIsAtTop() ) {}
  motor[Elevator] = 0;

  //  position slide
  servo[Slide] = kSlideLongPosition;

  //  kick batons out
  servo[Kicker] = kKickerSpeed;
  long endTime = nPgmTime + 9500;  //go for 9.5 seconds

  nMotorEncoder[Left] = 0;  //  reset encoder so vibrate works ok
  while ( nPgmTime < endTime )
  {
    if ( !vibrating ) StartTask(vibrate); //  vibrate to make sure the batons come out
  }

  servo[Slide] = kSlideMaxPosition;
  wait10Msec(20);

  servo[Kicker] = kKickerStopped;
}



#define DEBUG 0
#define PRELOADS 1
#define MISSION 0
#define BALANCE 1



task main()
{
	initializeRobot();

	Node targetBridge = (FieldGetCurrentNode() == NodeFriendStartSquareLeft) ? NodeFoeBridgeCenter : NodeFriendBridgeCenter;


#if DEBUG == 0
	waitForStart();
#endif

	long startTime = nPgmTime;




	/**********   Preloads   **********/
#if PRELOADS == 1


	if ( FieldGetCurrentNode() == NodeFriendStartSquareLeft ) //  left start position;
	{

    servo[Slide] = kSlideLongPosition;  //  extend the slide out

	  RobotRotateToOrientation(0.13);
	  RobotMoveDistance(20, false);
	  RobotRotateToOrientation(-1.5 + (PI / 11));

	  Dispense5Batons();



	  //  push the goal out of the way
	  RobotRotateToOrientation(PI / 6);
	  RobotMoveDistance(12, false);
	  RobotMoveDistance(-13, false);



	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine1BottomEnd, location);
	  RobotMoveToLocation(location, false, false);
	  FieldSetCurrentNode(NodeLine1BottomEnd);
	}
	else
	{
	  //  go to mobile goal & line up next to it
	  RobotRotateToOrientation(3.0159423);
	  RobotMoveDistance(21, false);


    servo[Slide] = kSlideLongPosition;  //  extend the slide out

	  RobotRotateToOrientation(PI / 3.5);



	  Dispense5Batons();


	  //wait10Msec(500); //  FIXME: remove this wait



	  //  FIXME: push mobile goal out of the way!!!



	  //  go back to the node
	  Vector location;
	  FieldGetNodeLocation(NodeLine3BottomEnd, location);
	  RobotMoveToLocation(location, false, false);
	  FieldSetCurrentNode(NodeLine3BottomEnd);
	}

	servo[Slide] = kSlideDownPosition;  //  retract the slide to keep it protected



#endif
	/********** End Preloads  **********/






	/**********  Mission   **********/
#if MISSION == 1

	//  where we are and where we're going
	Node src = FieldGetCurrentNode();
	Node dest = NodeFriendDispenserCenter;

	if ( RobotTravelFromNodeToNode(src, dest, true) )	// go to the dispenser.  avoid enemies
  {
    RobotRotateToOrientation(PI / 2.0); //  turn towards dispenser

    servo[Gate] = kGateUpPosition;

    MechanismElevatorSetHeight(kElevatorHeightMidDispenser);  //  get the elevator to the right height

    if ( RobotMountCenterDispenser() )	//	get aligned with the dispenser
    {
      for ( int i = 0; i < 3; i++ )
      {
        MechanismElevatorSetHeight(kElevatorHeightMidDispenser + 1);
        wait10Msec(100);

        RobotMoveDistance(-.5, false);
        wait10Msec(20);

        RobotMoveDistance(-.5, false);
        wait10Msec(20);

        RobotMoveDistance(-.5, false);
        wait10Msec(20);


        MechanismElevatorSetHeight(kElevatorHeightMidDispenser);

        RobotMoveDistance(1.5, false);
      }



      //  FIXME: DO WORK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    }


    servo[Gate] = kGateDownPosition;
  }

  Vector location;
  FieldGetNodeLocation(NodeFriendDispenserCenter, location);
  RobotMoveToLocation(location, true, false);   //  backup to the node


#endif
  /**********   End Mission   **********/





  //  put elevator at bottom
  motor[Elevator] = -kElevatorSpeed;
  while ( !ElevatorIsAtBottom() ) {}
  motor[Elevator] = 0;





  /**********   Balance   **********/
#if BALANCE == 1

  if ( (nPgmTime - startTime ) > 3000 )  //  balance on the bridge if there's more than 3 seconds left
	{
	  Node currentID = FieldGetCurrentNode();
	  RobotTravelFromNodeToNode(currentID, targetBridge, true);	//	go to the bridge

	  RobotMoveDistance(2.5 , false);

	  //RobotBalance();	//	use the accelerometor to balance the bot
	}

#endif
	/**********   End Balance **********/
}
